* org-node
** News [2024-07-11]
Version 0.2 in July brought many changes!  *If anything broke for you*, you can rollback to the 0.1pre branch:

#+begin_src elisp
(use-package org-node
  :straight (org-node :type git :host github :repo "meedstrom/org-node"
                      :branch "0.1pre")
  :hook (org-mode . org-node-cache-mode))
#+end_src

New features
- New mode: =org-node-roam-db-shim-mode=
  - Deprecates advice that was in [[https://github.com/meedstrom/org-node?tab=readme-ov-file#option-1b--tell-org-node-to-write-to-the-org-roam-db][Backlinks Option 1B]]
- New mode: =org-node-roam-no-sql-mode=
  - Deprecates advice that was in [[https://github.com/meedstrom/org-node?tab=readme-ov-file#option-1c--cut-out-the-db-altogether][Backlinks Option 1C]]
- New mode: =org-node-roam-redisplay-mode=
- New mode: =org-node-capf-mode=
- New user option: =org-node-prefer-file-level-nodes=
- New user option: =org-node-warn-title-collisions=
- New user option: =org-node-affixation-fn=
  - Deprecates old option =org-node-format-candidate-fn=
- New user option: =org-node-alter-candidates=
- New command: =org-node-lint-all-files=
  - Run org-lint on all known files, then report the results.  Use it to fix a broken setup; org-node [[https://github.com/meedstrom/org-node/issues/8#issuecomment-2101316447][assumes all files have correct syntax]].  In particular, malformed PROPERTIES drawers easily cause failure to scan.
- New command: =org-node-list-dead-links=
- New command: =org-node-list-feedback-arcs=
- New command: =org-node-grep=
- ... and other minor functions

Removals
- Remove user option: =org-node-perf-gc-cons-threshold=
- Remove user option: =org-node-format-candidate-fn= (in favour of =org-node-affixate-fn=)
- Remove variable: =org-node-cache-reset-hook=
- Rename variable: =org-node-cache-rescan-file-hook= (in favour of =org-node-rescan-hook=, now called with 1 argument)

Renames
- Rename user option =org-node-slug-fn= to =org-node-filename-fn=
- Rename variable =org-node-collection= to =org-node--node-by-candidate=.
- Rename many private functions and variables

Changes
- Don't automatically turn on cache-mode, just pester the user
- Command =org-node-put-created= now respects =org-timestamp-formats= instead of just putting the date as [YYYY-MM-DD].
- Fix: catch some nodes that were missed
- Fix: the feature of feeding files to the Roam DB (now called =org-node-roam-db-shim-mode=) was subtly broken because it'd trigger the hook before the scan completed, so it'd always be a bit outdated, now fixed.
- Fix: quickly update completions when a heading was edited, instead of seeing multiple stale candidates
- Fix: Accept multiple =#+todo:= lines
- Fix: fix =:BACKLINKS:= members sometimes disappearing
- Fix: fix =org-node-insert-transclusion-as-subtree= inserting asterisks after the link
- Fix: fix some backlink-mode errors
- Fix: fix org-get-title missing in Emacs 28
- Perf: backlink-mode no longer tries to clean up =:CACHED_BACKLINKS:= (deprecated in May); if you still have those lying around, checkout 0.1pre and run =M-x org-node-backlink-fix-all=

** What's all this

I found org-roam too slow, so I made [[https://github.com/meedstrom/quickroam][quickroam]].  And that idea spun off into this package, a standalone thing.  I hope it's also easier to learn.

- *If you were using org-roam*, there is nothing to migrate.  You can use both packages.  It's exactly the same on-disk format: "notes" are identified by their org-id.

  With optional shims, you can even *skip syncing the org-roam DB* and continue using its rich backlinks buffer and org-roam-capture!

  In pursuit of being "just org-id", this package has no equivalent setting to =org-roam-directory= -- it just looks up =org-id-locations=.

- *If you were not using org-roam*, maybe think of it as somewhat like [[https://github.com/alphapapa/org-recent-headings][org-recent-headings]] beefed-up to the extent that you won't need other methods of browsing or linking.

  If you were the sort of person to prefer ID-links over file links or any other type of link, you're in the right place!  Now you can rely on IDs, and---/if you want/---forget about filenames and subtree hierarchies and directory structures.  As long as you've assigned an ID to something, you can find it later.

** What's a "node"?

My life can be divided into two periods "*before org-roam*" and "*after org-roam*".  I crossed a kind of gap once I got a good way to link between my notes.  It's odd to remember when I just relied on browsing hierarchies of subtrees -- what an odd way to work!

I used to lose track of things I had written, under some forgotten heading in a forgotten file in a forgotten directory.  The org-roam method let me *find* and *build on* my own work, instead of having repetitive [[https://en.wikipedia.org/wiki/Cryptomnesia][cryptomnesia]] and staying on square one forever.

At the core, all the "notetaking packages" ([[https://github.com/rtrppl/orgrr][orgrr]]/[[https://github.com/localauthor/zk][zk]]/[[https://github.com/EFLS/zetteldeft][zetteldeft]]/[[https://github.com/org-roam/org-roam][org-roam]]/[[https://github.com/protesilaos/denote][denote]]/[[https://github.com/kaorahi/howm][howm]]/[[https://github.com/kisaragi-hiu/minaduki][minaduki]]/...) try to help you with this: make it easy to link between notes and explore them.

Right off the bat, that imposes two requirements: a method to search for notes, since you can't link to something you can't search for, and a design-philosophy about exactly what kinds of things should turn up as search hits.  What's a "note"?

Just searching for Org files is too coarse, and just searching for any subtree anywhere brings in too much clutter.

Here's what org-roam invented.  It turns out that if you limit the search-hits to just those files and subtrees you've deigned to assign an org-id -- which roughly maps to /everything you've ever thought it was worth linking to/ -- it filters out the noise excellently.

Once a subtree has an ID you can link to, it's a "node" because it has joined the wider graph, the network of linked nodes.  I wish the English language had more distinct sounds for the words "node" and "note", but to clarify, I'll say "ID-node" when the distinction matters.

** Features

A comparison of three similar systems, all permitting org-id as first-class citizen, and not locking you into an "one-note-per-file" concept.

| Feature                           | org-roam | org-node           | [[https://github.com/toshism/org-super-links][org-super-links]]      |
|-----------------------------------+----------+--------------------+----------------------|
| Backlinks                         | yes      | yes                | yes                  |
| Node search and insert            | yes      | yes                | -- (suggests [[https://github.com/alphapapa/org-ql][org-ql]]) |
| Node aliases                      | yes      | yes                | --                   |
| Rich backlinks buffer             | yes      | yes (org-roam's)   | --                   |
| Reflinks                          | yes      | yes (as backlinks) | --                   |
| Ref search                        | yes      | yes (as aliases)   | --                   |
| Can have rich search completion   | yes      | yes                | not applicable       |
| Can work thru org-roam-capture    | yes      | yes                | --                   |
| Can work thru org-capture         | --       | yes                | --                   |
| Can show backlinks in same window | --       | yes                | yes                  |
| Avoid double-counting =:BACKLINKS:= | --       | yes                | not applicable       |
| Grep across all files             | --       | yes                | --                   |
| Update stale link descriptions    | --       | yes                | --                   |
| List dead links                   | --       | yes                |                      |
| Warn about duplicate IDs          | --       | yes                |                      |
| Node exclusion                    | yes      | limited            | not applicable       |
| Support Org 9.5 citations         | yes      | -- (planned)       | --                   |
| Support org-ref                   | yes      | -- (WONTFIX)       | --                   |
| Support =roam:= links               | yes      | -- (WONTFIX)       | --                   |
| Can have separate note piles      | yes      | -- (WONTFIX)       | not applicable       |
|-----------------------------------+----------+--------------------+----------------------|
| Some query-able cache             | EmacSQL  | hash tables        | --                   |
| Async caching                     | --       | yes                | not applicable       |
| Time to re-cache my 3000 nodes    | 2m 48s   | 0m 02s             | not applicable       |

* Setup

Add an init snippet like this (assuming [[https://github.com/radian-software/straight.el][straight.el]]):

#+begin_src elisp
(use-package org-node
  :straight (org-node :type git :host github :repo "meedstrom/org-node")
  :hook (org-mode . org-node-cache-mode))
#+end_src

** Quick start

If you're new to these concepts, fear not.  The main things for day-to-day operation are two verbs: "find" and "insert-link".

Pick some good keys, close the browser, and try them out.

#+begin_src elisp
(global-set-key (kbd "<f2> f") #'org-node-find)
(global-set-key (kbd "<f2> i") #'org-node-insert-link)
#+end_src

(If you don't like F2, maybe M-s?)

#+begin_src elisp
(global-set-key (kbd "M-s f") #'org-node-find)
(global-set-key (kbd "M-s i") #'org-node-insert-link)
#+end_src

To browse config options, type =M-x customize-group RET org-node RET=.

Final tip for the newbie: there's no separate command for creating a new node!  Reuse one of the commands above, and type the name of a node that doesn't exist.  Try it and see what happens!

** Use Org-roam at the same time?

These settings help you feel at home using both packages side-by-side:

#+begin_src elisp
(setq org-node-creation-fn #'org-node-new-by-roam-capture)
(setq org-node-filename-fn #'org-node-slugify-like-roam)
#+end_src

If you've been struggling with slow saving of big files in the past, consider these org-roam settings:

#+begin_src elisp
(setq org-roam-db-update-on-save nil) ;; don't update DB on save, not needed
(setq org-roam-link-auto-replace nil) ;; don't look for "roam:" links on save
#+end_src

Finally, make sure org-id knows all the files org-roam knows about (you'd think it would, but that isn't a given!).  Either run =M-x org-roam-update-org-id-locations=, or edit the following setting so it includes your =org-roam-directory=.  If your =org-roam-directory= is "~/org/":

#+begin_src elisp
(setq org-node-extra-id-dirs '("~/org/"))
#+end_src

With that done, try out the commands we went over in [[https://github.com/meedstrom/org-node?tab=readme-ov-file#quick-start][Quick start]].  There's more under [[https://github.com/meedstrom/org-node?tab=readme-ov-file#toolbox][Toolbox]].  Enjoy!

If you want to see the org-roam-buffer, see the next section.

** Backlink solution 1: borrow org-roam's backlink buffer

Want to keep using =M-x org-roam-buffer-toggle=?

**** *Option 1A.*  Let org-roam manage its own DB

If you didn't have laggy saves, this is fine.  In other words, keep =org-roam-db-update-on-save= at t.


**** *Option 1B*.  Tell org-node to write to the org-roam DB

Use this minor mode:

#+begin_src elisp
(org-node-roam-db-shim-mode)
(setq org-roam-db-update-on-save nil)
#+end_src

To full-reset the DB, you're free to use the original =C-u M-x org-roam-db-sync=, or the faster =M-x org-node-roam-db-reset=, bearing in mind results aren't 100% identical.


**** *Option 1C*.  Cut out the DB altogether

Yes it's possible, no SQLite needed!

Type =M-x org-node-roam-no-sql-mode=, then see what populates your Roam buffer henceforth.  Hopefully you see the same links as before.

If you're happy with the result, and you don't need =roam:= links functionality, you can disable =org-roam-db-autosync-mode= in favour of the slimmer =M-x org-node-roam-redisplay-mode=.  As an init snippet:

#+begin_src elisp
(org-roam-db-autosync-mode 0)
(org-node-roam-no-sql-mode)
(org-node-roam-redisplay-mode)
#+end_src

** Backlink solution 2: print inside the file
I like these solutions because I rarely have the screen space to display a backlink buffer.

**** *Option 2A*.  Let org-node add a =:BACKLINKS:= property to all nodes

For a first-time run, type =M-x org-node-backlink-fix-all=.  (Don't worry, if you change your mind, you can undo with =M-x org-node-backlink-regret=.)

Then start using the minor mode =org-node-backlink-mode=, which keeps these properties updated.  Init snippet:

#+begin_src elisp
(add-hook 'org-mode-hook #'org-node-backlink-mode)
#+end_src

#+begin_quote
[!NOTE] Beware if you have giant files with thousands of subtree nodes.  A file with so many backlinks can weigh down Emacs' font-locking engine.

You can make it fast again by adding these file-local variables atop the file, but that has its own (visual) consequences.

: # -*- jit-lock-contextually: nil;  jit-lock-defer-time: 0; -*-
#+end_quote

**** *Option 2B.*  Let [[https://github.com/toshism/org-super-links][org-super-links]] manage a =:BACKLINKS:...:END:= drawer in all nodes

I /think/ the following should work. Totally untested, let me know!

#+begin_src elisp
(add-hook 'org-node-insert-link-hook #'org-node-convert-link-to-super)
#+end_src

Alas, this is currently directed towards people who used org-super-links from the beginning, or people who are just now starting to assign IDs, as there is not yet a command to add new BACKLINKS drawers in bulk to preexisting nodes. ([[https://github.com/toshism/org-super-links/issues/93][org-super-links#93]])

** Misc
*** Org-capture

You may have heard that org-roam has its own set of capture templates: the =org-roam-capture-templates=.

It can make sense, for people who fully understand the magic of capture templates.  I didn't, so I was not confident using a second-order abstraction over an already leaky abstraction.

So can we reproduce the functionality on top of vanilla org-capture?  That'd be less scary.  The answer is yes!

Here are some example capture templates. The secret sauce is =(function org-node-capture-target)=.

#+begin_src elisp
(setq org-capture-templates
      '(("n" "ID node")
        ("nc" "Capture into ID node (maybe creating it)"
         plain (function org-node-capture-target) nil
         :empty-lines-after 1)

        ("nv" "Visit ID node (maybe creating it)"
         plain (function org-node-capture-target) nil
         :jump-to-captured t
         :immediate-finish t)

        ;; Sometimes useful with `org-node-insert-link' to make a stub you'll
        ;; fill in later
        ("ni" "Instantly create stub ID node without visiting"
         plain (function org-node-capture-target) nil
         :immediate-finish t)))
#+end_src

And if you want the commands =org-node-find= & =org-node-insert-link= to likewise outsource to org-capture when creating new nodes:

#+begin_src elisp
(setq org-node-creation-fn #'org-capture)
#+end_src

*** Managing org-id-locations

I find unsatisfactory the config options in org-id (Why? See [[http://edstrom.dev/wjwrl/taking-ownership-of-org-id][Taking ownership of org-id]]), so org-node gives you an additional way to feed data to org-id, making sure we won't run into "ID not found" situations.

Example setting:

#+begin_src elisp
(setq org-node-extra-id-dirs
      '("/home/kept/notes/"
        "/home/kept/project1/"
        "/home/kept/project2/")
#+end_src

(The problem with the upstream org-id options is that they all let you specify /files/ but not /directories/ meaning there's no way to detect /new files/.

Even =org-agenda-files= won't help here -- that option /seems/ to let you specify directories, but actually replaces each directory with the files found within them at some point in time, and then does not notice new files.)

*** Instruct org-open-at-point to visit ref-node if one exists

Say you there's a link to a web URL, and you've forgot you have a node listing that exact URL in =ROAM_REFS=.

Would it be nice if, clicking on it, you're automatically sent to that node instead of going on the web?

#+begin_src elisp
(add-hook 'org-open-at-point-functions #'org-node-try-visit-ref-node)
#+end_src

*** Limitation: unique titles
RSS
If two ID-nodes exist with the same title, one of them will disappear from minibuffer completions.

That's just the nature of completion, and much can be said for embracing an uniqueness constraint anyway.  Org-node will print messages telling you about title collisions (controlled by the option =org-node-warn-title-collisions=).

Anyway, there's a workaround.  Assuming you leave =org-node-affixation-fn= at its default setting, set =org-node-alter-candidates= to t.

Because this merges the outline path with the matchable part of each candidate (so you do not match only on title), it resolves practically all conflicts.  [[https://fosstodon.org/@nickanderson/112249581810196258][Some people]] depend on that workflow.

Final note: this workaround won't help the in-buffer completions provided by =org-node-capf-mode=, but hopefully you won't need it often.

# Maybe I'll add distinguishers like "1" "2" "3" to each naming conflict?

*** Limitation: excluding notes
The option =org-node-filter-fn= works well for excluding TODO items that happen to have an ID, and excluding org-drill items and that sort of thing, but beyond that, it has limited utility because unlike org-roam, *child ID nodes of an excluded node are not excluded!*

So let's say you have a big archive file, fulla IDs, and you want to exclude all of them from appearing as search hits.  Putting a =:ROAM_EXCLUDE: t= at the top won't do it.  As it stands, what I'd suggest is unfortunately, look at the file name.

While the point of IDs is to avoid depending on exact filenames, it's often pragmatic to let up on purism just a bit :-) It works well for me to filter out any file or directory that happens to contain "archive" in the name, via the last line here:

#+begin_src elisp
(setq org-node-filter-fn
      (lambda (node)
        (not (or (org-node-get-todo node) ;; Ignore headings with todo state
                 (member "drill" (org-node-get-tags node)) ;; Ignore :drill:
                 (assoc "ROAM_EXCLUDE" (org-node-get-properties node))
                 (string-search "archive" (org-node-get-file-path node))))))
#+end_src

*** Limitation: TRAMP
Working over TRAMP is untested, but I suspect it won't work.  Org-node tries to be very fast, often nulling =file-name-handler-alist=, but TRAMP needs it non-nil.

If you need TRAMP, use org-roam, which is made to /not/ re-access files or directories so often anyway, in favor of trusting its own DB.

(That being the other half of my beef with org-roam.  My usage patterns led to an out-of-sync DB all the time, better check the disk files more often!)

*** Toolbox

Basic commands:

- =org-node-find=
- =org-node-insert-link=
- =org-node-insert-transclusion=
- =org-node-insert-transclusion-as-subtree=
- =org-node-visit-random=
- =org-node-rename-file-by-title=
  - Auto-rename the file based on the current =#+title=
- =org-node-extract-subtree=
  - A bizarro counterpart to =org-roam-extract-subtree=.  Export a subtree at point into a file-level node, leave a link where it was, and show the new file as the current buffer.
- =org-node-nodeify-entry=
  - (Trivial) Give an ID to the subtree at point (and run org-node-creation-hook)
- =org-node-insert-heading=
  - (Trivial) Like =org-insert-heading= + =org-node-nodeify-entry=

Rarer commands:

- =org-node-rewrite-links-ask=
  - Look for link descriptions that got out of sync with the current node title, then prompt at each link to update it
- =org-node-rename-asset-and-rewrite-links=
  - Interactively rename an asset such as an image file and try to update all Org links to them.  Requires [[https://github.com/mhayashi1120/Emacs-wgrep][wgrep]].
    - NOTE: For now, it only looks for links inside the root directory that it prompts you for, and sub and sub-subdirectories and so on -- but won't find a link in a completely different place.  Like if you have Org files under /media linking to assets in /home, those links won't be updated.
- =org-node-lint-all-files=
  - An utility to help fix a broken setup: it runs org-lint on all known files and generates a report of syntax problems.  Org-node [[https://github.com/meedstrom/org-node/issues/8#issuecomment-2101316447][assumes all files have valid syntax]], in particular around PROPERTIES drawers.
- =org-node-backlink-fix-all=
  - Add =BACKLINKS= property to all nodes everywhere (takes a while)
- =org-node-backlink-regret=
  - In case you regret the =BACKLINKS= properties -- remove them all
- =org-node-list-feedback-arcs=
  - (Requires GNU R---see docstring) Explore [[https://en.wikipedia.org/wiki/Feedback_arc_set][feedback arcs]] among your ID links.  Can be a nice occasional QA routine, like exploring your note pile in org-roam-ui or Delve and realizing there should/shouldn't be connections here and there.
- =org-node-grep=
  - (Requires [[https://github.com/minad/consult][consult]]) Grep across all known Org files.  Very useful combined with [[https://github.com/oantolin/embark][embark]]-export & [[wgrep][wgrep]] to search-and-replace a given string everywhere.  For example, if you want to rename a tag everywhere.

* Appendix
** Appendix I: Rosetta stone

API comparison between org-roam and org-node.

| Action                                  | org-roam                           | org-node                                                                   |
|-----------------------------------------+------------------------------------+----------------------------------------------------------------------------|
| Get ID near point                       | =(org-roam-id-at-point)=             | =(org-entry-get nil "ID" t)=                                                 |
| Get node at point                       | =(org-roam-node-at-point)=           | =(org-node-at-point)=                                                        |
| Get list of files                       | =(org-roam-list-files)=              | =(org-node-files)=                                                           |
| Prompt user to pick a node              | =(org-roam-node-read)=               | =(org-node-read)=                                                            |
| Get backlink objects                    | =(org-roam-backlinks-get NODE)=      | =(org-node-get-backlinks NODE)=                                              |
| Get reflink objects                     | =(org-roam-reflinks-get NODE)=       | =(org-node-get-reflinks NODE)=                                               |
| Get title                               | =(org-roam-node-title NODE)=         | =(org-node-get-title NODE)=                                                  |
| Get title of file where NODE is         | =(org-roam-node-file-title NODE)=    | =(org-node-get-file-title NODE)=                                             |
| Get title /or/ name of file where NODE is |                                    | =(org-node-get-file-title-or-basename NODE)=                                 |
| Get ID                                  | =(org-roam-node-id NODE)=            | =(org-node-get-id NODE)=                                                     |
| Get filename                            | =(org-roam-node-file NODE)=          | =(org-node-get-file-path NODE)=                                              |
| Get tags                                | =(org-roam-node-tags NODE)=          | =(org-node-get-tags NODE)=, no inherited tags                                |
| Get outline level                       | =(org-roam-node-level NODE)=         | =(org-node-get-level NODE)=                                                  |
| Get whether this is a subtree           | =(zerop (org-roam-node-level NODE))= | =(org-node-get-is-subtree NODE)=                                             |
| Get char position                       | =(org-roam-node-point NODE)=         | =(org-node-get-pos NODE)=                                                    |
| Get properties                          | =(org-roam-node-properties NODE)=    | =(org-node-get-properties NODE)=, no inherited properties                    |
| Get subtree TODO state                  | =(org-roam-node-todo NODE)=          | =(org-node-get-todo NODE)=, only that match global =org-todo-keywords=         |
| Get subtree SCHEDULED                   | =(org-roam-node-scheduled NODE)=     | =(org-node-get-scheduled NODE)=                                              |
| Get subtree DEADLINE                    | =(org-roam-node-deadline NODE)=      | =(org-node-get-deadline NODE)=                                               |
| Get subtree priority                    | =(org-roam-node-priority NODE)=      | =(org-node-get-priority NODE)=                                               |
| Get outline-path                        | =(org-roam-node-olp NODE)=           | =(org-node-get-olp NODE)=                                                    |
| Get =ROAM_REFS=                           | =(org-roam-node-refs NODE)=          | =(org-node-get-refs NODE)=                                                   |
| Get =ROAM_ALIASES=                        | =(org-roam-node-aliases NODE)=       | =(org-node-get-aliases NODE)=                                                |
| Get =ROAM_EXCLUDE=                        |                                    | =(assoc "ROAM_EXCLUDE" (org-node-get-properties NODE))=, no parent excludes! |
| Ensure fresh data                       | =(org-roam-db-sync)=                 | =(org-node-cache--scan-new-or-modified)=                                     |

** Appendix II: Deeper differences

I sometimes call org-node a "bizarro org-roam".  Why?

1. Org-node treats =ROAM_REFS= more like aliases, and it treats the associated concept "reflinks" like backlinks.
   - I suspect it's easier to get started with refs if you don't /call/ them refs.  There must be many people today who remain unsure what a "roam ref" is, because they have a backlog of 500 other Emacs/Org concepts to learn.  And it's not actually a concept that needs a name.

     The distinction between a reflink and a backlink comes from technical implementation, but an user shouldn't have to know about it.

     If I cared not for compatibility, I might have called my version of the =ROAM_REFS= property =EXTRA_IDS=.  I think that says a lot more about how it really works.  When you see someone putting a web URL in an =EXTRA_IDS= property, you can sorta intuit what's going on.

     I even considered merging it with the =ID= property(!), but there is one way in which a =ROAM_REFS= is not equivalent to an =ID=:  sometimes you want to search for refs (org-roam provides the command =org-roam-ref-find=), but you never want to search for IDs, since they're usually nonsensical UUIDs.

     But, /again/, the user doesn't need two separate commands or mental buckets: =org-node-find= does both, as if the =ROAM_REFS= was really the =ROAM_ALIASES= field.  Though a small detail differs there: the user option =org-node-affixate-fn= is not applied, whereas it is applied to real aliases.

2. The command =org-node-extract-subtree= places you in the newly created buffer so you can check the result, the opposite of =org-roam-extract-subtree= which actually /buries/ the buffer so it's difficult to check.

3. Org-roam is the most general toolkit.  Take a function like =org-roam-id-at-point=.  Why does it exist, when you could use =(org-entry-get nil "ID" t)=?  Well, the org-roam version ignores those ancestor headings that have an ID but have been marked not to count as "Roam nodes", so it travels further up the tree until it finds one that is indeed "a Roam node".

   - This brings good to some users.  Complexity is not the enemy.  It's just a bit of a YAML vs TOML situation.  Or lsp-mode vs eglot.  I prefer to try to be "closer to the metal", use vanilla =org-capture= instead of =org-roam-capture=, look up vanilla =org-id-locations= instead of =org-roam-directory= etc.  Less wrappers.

4. Take the variable =org-roam-node-display-template=.  At least, others may consider this a pro, but for my tastes no.  I try to let people customize with little lambdas and provide examples of how they'd get some result or other.  This instead has the dream UI where you can just set the variable to a string "${olp} ${tags} ${title}" or some such and be done with it.  Problem is it's a new mini-DSL (domain-specific language), and when you learn it you miss out on an elisp lesson.  Convenient for beginners but also /keeps/ them beginners.
